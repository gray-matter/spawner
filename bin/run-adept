#! /usr/bin/env ruby

# FIXME
$LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")

require 'spawner/adept'
require 'drb'
require 'optparse'
require 'thread'

HUGE_TIMEOUT_TO_AVOID_DEADLOCK = 42424242

persistent = false

options_parser = OptionParser.new()

options_parser.banner = "Usage: #$0 [options] command"
options_parser.on_head('-h', '--help', 'Print this usage') do
  puts options_parser
  exit 1
end

options_parser.on('-p', '--persistent', 'Whether this script shall exit after running the first duty or not') do
  persistent = true
end

options_parser.parse!()

if (ARGV.size() != 1)
  $stderr.puts options_parser
  exit 1
end

# Use a mutex to avoid the scenario :
# Thread 1: There's no job, going to sleep
# Thread 2: There's a new job, wake the worker up
# Thread 1: Worker already awake, go to sleep
wake_up_mutex = Mutex.new()
worker_stopping = false
worker_thread = nil

duty_container_drb_uri = ARGV[0]
duty_container = nil
duty_container_mutex = Mutex.new()
duty_container_cond = ConditionVariable.new()
duty = nil

begin
  # Retrieve the object shared by the remote server
  duty_container = DRbObject.new(nil, duty_container_drb_uri)
rescue
  $stderr.puts "Error: unable to connect to the conductor"
  exit 1
end

Signal.trap('CONT') do
  duty_container_mutex.synchronize() do
    duty_container_cond.signal()
  end
end

Signal.trap('TERM') do
  # FIXME: notify something/do something w/ the current duty
  Thread.kill(worker_thread)
end

$stdout.sync = true

worker_thread = Thread.new() do
  # We want to catch anything BUT our own exceptions
  Thread.current[:error_in_spawner] = true

  if !duty_container.nil?()
    adept = Spawner::Adept.new()

    begin
      duty_container_mutex.synchronize() do
        # This is the single most important line of this whole script. Do not
        # wait if there's something to do, but if not, wait patiently for
        # someone to wake us up.
        duty_container_cond.wait(duty_container_mutex) if !duty_container.has_duty?()

        # Duty shall NEVER be nil !
        duty = duty_container.get_duty()

        Thread.current[:error_in_spawner] = false
        adept.give_duty(duty)
      end
    end while persistent
  end
end

begin
  # Hack: if we don't specify a timeout, join will throw a "deadlock detected"
  # exception when the worker thread hits the "Thread.stop()" part, thinking that
  # we're waiting for something that will never happen, even though a "CONT"
  # signal might (and should) wake it up.
  worker_thread.join(HUGE_TIMEOUT_TO_AVOID_DEADLOCK)
rescue Exception => e
  if worker_thread[:error_in_spawner]
    # If this is an error related to the spawner itself, die
    raise e
  else
    duty.report_failure(e) unless duty.nil?()
  end
end
