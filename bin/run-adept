#! /usr/bin/env ruby

# FIXME
$LOAD_PATH.unshift("#{File.dirname(__FILE__)}/../lib")

require 'spawner/adept'
require 'drb'
require 'optparse'

HUGE_TIMEOUT_TO_AVOID_DEADLOCK = 42424242

persistent = false

options_parser = OptionParser.new()

options_parser.banner = "Usage: #$0 [options] command"
options_parser.on_head('-h', '--help', 'Print this usage') do
  puts options_parser
  exit 1
end

options_parser.on('-p', '--persistent', 'Whether this script shall exit after running the first duty or not') do
  persistent = true
end

options_parser.parse!()

if (ARGV.size() != 1)
  $stderr.puts options_parser
  exit 1
end

# Use a mutex to avoid the scenario :
# Thread 1: There's no job, going to sleep
# Thread 2: There's a new job, wake the worker up
# Thread 1: Worker already awake, go to sleep
wake_up_mutex = Mutex.new()
worker_stopping = false
worker_thread = nil

# FIXME : use a ConditionVariable instead
Signal.trap('CONT') do
  wake_up_mutex.lock()

  if !worker_stopping
    wake_up_mutex.unlock()
  else
    wake_up_mutex.unlock()

    # Wait for the worker to stop for real...this shouldn't be too long
    while !worker_thread.stop?()
      Thread.pass()
    end

    worker_thread.run()
  end
end

Signal.trap('TERM') do
  # FIXME: notify something/do something w/ the current duty
  Thread.kill(worker_thread)
end

duty_container_drb_uri = ARGV[0]
duty_container = nil
duty = nil

begin
  # Retrieve the object shared by the remote server
  duty_container = DRbObject.new(nil, duty_container_drb_uri)
rescue
  $stderr.puts "Error: unable to connect to the conductor"
  exit 1
end

while persistent
  worker_thread = Thread.new() do
    # We want to catch anything BUT our own exceptions
    Thread.current[:error_in_spawner] = true

    if !duty_container.nil?()
      adept = Spawner::Adept.new()

      begin
        wake_up_mutex.lock()

        duty = duty_container.get_duty()

        if duty.nil?()
          worker_stopping = true
          wake_up_mutex.unlock()

          # Instead of waiting actively, go to sleep and wait for the spawner to wake us
          # up
          Thread.stop()

          wake_up_mutex.synchronize() do
            worker_stopping = false
          end
        else
          wake_up_mutex.unlock()
          Thread.current[:error_in_spawner] = false
          adept.give_duty(duty)
        end
      end while persistent
    end
  end

  begin
    # Hack: if we don't specify a timeout, join will throw a "deadlock detected"
    # exception when the worker thread hits the "Thread.stop()" part, thinking that
    # we're waiting for something that will never happen, even though a "CONT"
    # signal might (and should) wake it up.
    worker_thread.join(HUGE_TIMEOUT_TO_AVOID_DEADLOCK)
  rescue Exception => e
    if worker_thread[:error_in_spawner]
      # If this is an error related to the spawner itself, die
      raise e
    else
      duty.report_failure(e)
    end
  end
end
